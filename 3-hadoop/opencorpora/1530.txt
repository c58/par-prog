Есть такая черта у Лиспа, которая мне нравится и которая иногда бывает очень раздражающей — в лиспе сложно понять, дорогая ли данная конструкция или нет (дорогая в плане производительности). Есть две стороны этой «медали» — это позволяет писать довольно сложные алгоритмы не сильно задумываясь о сложности реализации (не об алгоритмической сложности, а о той самой константе при O(f(n)), которая становится довольно большой), с другой стороны, иногда приходится задумываться о реализации и скорости исполнения, и тогда выясняется, что есть много мест, в которых производительность съедается зря.
Например, выяснилось, что в одном коде у меня значительная часть производительности теряется в функции сравнения объектов. Оказалось, что каждый вызов функции сравнения выделяет небольшое количество памяти (порядка десятка-сотни байтов). Вроде бы, совсем ничего, но эта функция вызывается около десятка миллионов раз (это для обработки маленькой части той информации, которая должна быть обработана), и эти сотни байт выливаются в десятки и сотни гигабайтов, которые нагружают сборщик мусора.
В первоначальном варианте кода для анализа всего 4 статей из википедии таким образом выделялось 11 гигабайтов памяти. После добавления в некоторые места спецификаторов типов (просто добавил (the double-float (...)) в некоторые выражения и (type (double-float ...)) к определениям нескольких функций), выделение памяти упало до 4-х гигабайтов. Судя по всему, причина такого поведения в том, что компилятор не до конца справился с выведением типов, и делал честный boxing всех чисел и динамический dispatch всех арифметических операций по типам аргументов (ожидая, а вдруг там будет не вещественное число, а комплексное или длинное целое число), что требует выделения объектов в памяти. 4 гигабайта против 11 — уже неплохо.
Переделал некоторые вспомогательные функции в локальные функции, и выделение памяти упало в 2 раза — до 2 гигабайтов. Причина — boxing вещественных чисел при возврате их из функций, которого при замене на локальные функции компилятор смог избежать.
И, наконец, заменил вещественные числа с двойной точностью на вещественные с одинарной точностью. Выделение памяти упало до всего 400 мегабайтов. Причина, опять же, в боксинге. Только на этот раз из-за того, что для возврата из функции число нужно преобразовать в битовое представление с «меткой» (в лиспах обычно объекты в памяти представлены либо помеченными указателями (несколько бит указателя отводится на метку), либо помеченным значением (аналогично, несколько бит отводится на метку типа)), а размер double-float как раз составляет 64 бита, и на x86-64 не хватает нескольких битов, чтобы вместить помеченное значение, что создает необходимость боксить.
Что в такой оптимизации оказалось приятным: компилятор сам подсказывал узкие места программы, и профилировщик в SBCL очень простой и полезный. Если в SBCL установить режим оптимизации по скорости, то он будет указывать, в каких местах он не смог применить оптимизации, и по каким причинам (не смог вывести точный тип, необходимо боксить объект, и т.д.). И добавление всего нескольких подсказок компилятору дает эффективный код, который по производительности сравним с эквивалентным кодом на языке, более приближенном к машинному коду (на C). Но при этом не теряется читаемость и расширяемость кода. В общем-то, это благодаря прозрачности лиспа: если хочется, то можно спуститься с высоких уровней абстракции до очень низких (вплоть до машинного кода).
Кстати, это очередное обоснование необходимости перехода на 64-битные (а лучше и на 128-битные архитектуры): лишние биты в машинном слове компилятору не помешают (это верно для практически всех динамических языков и языков, реализованных на виртуальных машинах).
