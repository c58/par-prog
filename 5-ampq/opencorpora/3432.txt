§2. Общая концепция написания процедуры out. Итак, ещё раз общая концепция восстановления решения. Когда вы, придумывая рекуррентное соотношение, сводите текущую подзадачу к более мелким, вы сразу автоматически понимаете, как должно выглядеть оптимальное решение. Соответственно и процедуру out вы пишете, опираясь на это понимание и используя рекурсивный вызов для вывода ответа на ту подзадачу или те подзадачи, к которым вы свели текущую подзадачу. Ещё раз: особенно думать при написании процедуры out не надо, все, что надо было придумать, вы уже придумали, когда выводили рекуррентное соотношение. А теперь только вспомните его. Оно даёт сведение текущей подзадачи к более мелким и тогда, в точности следуя ему, можно свести вывод решения на текущую подзадачу к выводу решения на более мелкие подзадачи, и применить рекурсию для вывода этих более мелких решений.
На самом деле, далеко не всегда последовательность действий в процедуре out одна и та же: сначала вызвать out для подзадачи, потом вывести что-то ещё. Может быть так, что нужно вызвать out для одной подзадачи, потом что-то вывести, потом вызвать out для другой подзадачи; может быть так, что надо что-то вывести, потом вызвать out для подзадачи, потом ещё что-то вывести и т.д. в каждой конкретной задаче вполне очевидно, какой именно вариант имеет место: когда вы продумываете рекуррентное соотношение, вы сразу понимаете, как будет выглядеть соответствующее решение, и какой бы вариант ни был нужен, его очень легко реализовать в процедуре out.
Ещё замечу, что в рассмотренных выше примерах может возникнуть большое желание избавиться от рекурсии, выводя ответ с конца в начало это можно и довольно легко (Задание 14: избавьтесь от рекурсии в какой-нибудь из приведённых выше процедур out), но только мне кажется, что рекурсивный вариант намного более прозрачен и понятен. Конечно, он использует больше памяти (на стеке), и поэтому возможна ситуация, когда стека вам не хватит тогда придётся выводить нерекурсивно, но если все нормально и стека и времени хватает, то имхо вполне сойдёт и рекурсивная процедура. Кроме того, далеко не в каждом из перечисленных в предыдущем абзаце вариантов можно избавиться от рекурсии.
Единственная проблема, которая вас может ожидать при написании процедуры out таким способом это необходимость определять, какой именно из нескольких случаев в рекуррентном соотношении имел место (пришли мы слева или снизу; использовали мы или нет i-ю монету и т.п.). Пока с этим было просто; на самом деле, наверное, всегда можно просто ещё раз повторить вычисления, которые проводились в рекуррентном соотношении, и тем самым все понять. Но нередко писать это лень, да ещё дублирование кода создаст опасность лишних ошибок, наконец, повторять все проверки легко, пока у нас всего два варианта (как и было везде выше), но их может быть больше и заново перебирать их будет лишней тратой времени. В таком случае может быть полезно при вычислении массива ans сразу запоминать, какой из случаев в рекуррентном соотношении имел место («откуда мы пришли в эту клетку»), в специальном массиве from, и потом просто использовать его значения (если вы помните алгоритмы поиска кратчайших путей в графе, то это все очень аналогично). Пример будет ниже.
Обратите ещё внимание, что здесь вам обычно нужно знать весь массив ans, поэтому всякие трюки с сохранением только последних строк массива не пройдут.
